// -------------------------------------------------------------------------------------------------
// 2018-10-31  Поддержка многострочных заголовков для скроллингов

#ifndef _MULTIHDR_H_
#define _MULTIHDR_H_

#include <string>
#include <vector>

#include "menu.h"


// -----------------------------------------------------------------------------
// Размеры знакоместа
#define  dMH_CH_SIZE_H    20     // Высота (аналог STEPX)
#define  dMH_CH_SIZE_W    10     // Ширина (аналог STEPY)


#define  dMH_TEXT_SIZE   101     // Максимальная длина текста ячейки заголовка (с учетом 0-символа)

// -----------------------------------------------------------------------------
// Ячейка контрола заголовка
typedef struct TEWCell
      {
       TCHAR  *text;             // Текст ячейки
       TCHAR  *tooltipStr;       // Всплывающая подсказка к ячейке (динамический буфер)
       int     w;                // Ширина ячейки (текущая)
       int     idx;              // Номер ячейки в последней строке (индекс колонки, начинается с 0-ля)
       int     w_min,            // Минимальная ширина ячейки
               w_last,           // Ширина ячейки перед модификацией
               w_src;            // Исходная ширина ячейки
       bool    isLast;           // Признак самой нижней ячейки в заголовке

       // ----------------------------------------
       // Как-бы конструктор
       TEWCell()
       {
        memset(this, 0, sizeof(*this));
       }
      } TEWCell;

// -----------------------------------------------------------------------------
typedef  std::vector<TEWCell *>       TVEWCell;

// -----------------------------------------------------------------------------
// Контрол заголовка
typedef struct TEWHeader
      {
       TVEWCell  cells;          // Массив ячеек

       RECT      rc,             // Координаты контрола (текущие)
                 rc_last,        // Координаты контрола перед модификацией
                 rc_src;         // Координаты контрола (исходные)

       HWND      hWnd;           // Дескриптор окна контрола
       HWND      hWndTT;         // Окно всплывающих подсказок для контрола
       bool      isLast;         // Заполняется в easywin

       // ----------------------------------------
       // Как-бы конструктор
       TEWHeader()
       {
        memset(&rc,      0, sizeof(rc));
        memset(&rc_last, 0, sizeof(rc_last));
        memset(&rc_src,  0, sizeof(rc_src));

        hWnd = hWndTT = NULL;
       }
      } TEWHeader;

// -----------------------------------------------------------------------------
typedef  std::vector<TEWHeader *>       TVEWHeader;


// -----------------------------------------------------------------------------
// Класс для описания ячейки
typedef struct CCell
      {
       int     ctrlID,       // Идентификатор контрола
               cellID,       // Идентификатор ячейки в контроле
               x,            // Стартовая позиция ячейки в строке (начиная с символа '│')
               w,            // Ширина ячейки (в текселях)
               h;            // Высота ячейки (в строках)

       char    ch;           // Признак ячейки ('c')

       std::string  header;  // Заголовок ячейки

       int     isLast;       // Признак того, что ячейка последняя (самая нижняя)
       int     idxLast;      // Индекс последней ячейки (от 1; фактически, номер колонки)

       int     w_px,         // Ширина ячейки (в текселях)
               h_px;         // Высота ячейки (в текселях)

       int     x0,           // Координаты левого верхнего узла ячеки (в текселях)...
               y0,
               x1,           // ... и правого нижнего (в текселях)
               y1;

       // ----------------------------------------
       // Инициализатор
       void __Init(void)
       {
        ch = 0;

        ctrlID = 0;
        cellID = 0;

        x = w = 0;

        h = 1;

        header = "";

        isLast = false;

        idxLast = 0;

        w_px = h_px = 0;

        x0 = y0 = x1 = y1 = 0;
       }

       // ----------------------------------------
       // Дефолтный конструктор
       CCell()
       {
        __Init();

        ch = 'c';
       }

       // ----------------------------------------
       // Конструктор копирования
       CCell(const CCell &o)
       {
        __Init();


        // Пока копируем все поля, потом ненужные можно будет удалить
        ch = o.ch;

        ctrlID = o.ctrlID;
        cellID = o.cellID;

        x = o.x;
        w = o.w;

        header  = o.header;

        isLast  = o.isLast;
        idxLast = o.idxLast;

        w_px = o.w_px;
        h_px = o.h_px;

        x0 = o.x0;
        y0 = o.y0;
        x1 = o.x1;
        y1 = o.y1;
       }

       // ----------------------------------------
       int GetSize(void)
       {
        int  size = (int)header.size() + 1; // Включая 0-символ


        size += sizeof(db_int8);        // ch
        size += 4*sizeof(db_int16);     // size, width, last, idxLast

        return size;
       }
      } CCell;

// -----------------------------------------------------------------------------
typedef  std::vector<CCell *>         TVCellPtr;

// -----------------------------------------------------------------------------
// Класс для описания контрола
typedef struct CHeader
      {
       TVCellPtr  cells;      // Массив ячеек контрола (ссылки на объекты CCell)

       int   ctrlID;          // Идентификатор контрола

       char  ch;              // Признак контрола ('k')

       int   x0_px,           // Координаты левого верхнего угла контрола (в текселях)...
             y0_px,
             x1_px,           // ... и правого нижнего
             y1_px;

       // ----------------------------------------
       CHeader()
       {
        ch = 'k';

        ctrlID = 0;

        x0_px = y0_px = x1_px = y1_px = 0;
       }

       // ----------------------------------------
       int GetSize(void)
       {
        int  size = sizeof(db_int8);    // ch


        size += sizeof(db_int16);       // num
        size += 4*sizeof(db_int16);     // x0, y0, x1, y1


        for(size_t  i = 0; i < cells.size(); i++)
           size += cells[i]->GetSize();

        return size;
       }
      } CHeader;

// -----------------------------------------------------------------------------
typedef  std::vector<CHeader *>       TVHeaderPtr;

// -----------------------------------------------------------------------------
// Класс для описания узла
typedef struct CNode
      {
       char    ch;         // Символ узла (в дальнейшем можно заменить номером типа)

       int     x,          // Горизонтальная координата узла (начиная с 0)
               y;          // Вертикальная координата узла (начиная с 0)
       int     x_px,       // Экранные координаты узла (в текселях)
               y_px;
                           // Ссылки на соседние контролы (объектные с учётом ячеек):
       CCell  *olt,        //     левый верхний
              *olb,        //     левый нижний
              *ort,        //     правый верхний
              *orb;        //     правый нижний

       // ----------------------------------------
       CNode()
       {
        ch = 0;
        x = y = 0;

        x_px = y_px = 0;

        olt = olb = ort = orb = NULL;
       }
      } CNode;


// -----------------------------------------------------------------------------
// Интерфейс

// -----------------------------------------------------------------------------
int CreateMultiHeaderData(TVHeaderPtr *v, PANEL *mp, int *numRows = NULL);

// -----------------------------------------------------------------------------
void DeleteMultiHeaderData(TVHeaderPtr *v);

// -----------------------------------------------------------------------------
// Посчитать размер (байт) для передачи в EW
int GetMultiHeaderDataSize(TVHeaderPtr *v);

// -----------------------------------------------------------------------------
// Получить текст ячейки по заданному номеру столбца, принадлежащего ячейке
// В случае неуспеха возвращает NULL
const char *GetMultiHeaderCellTextO(TVHeaderPtr *v, int pos);

// -----------------------------------------------------------------------------
// Получить ширину колонки из данных заголовка
// Поиск ведется по самым последним ячейкам, поскольку их число должно совпадать
// с числом полей скроллинга.
// При ошибке возвращается значение -1
int GetMultiHeaderItemWidth(TVEWHeader &arr, int index);

// -----------------------------------------------------------------------------
// Расширенная версия GetMultiHeaderItemWidth
// Дополнительно возвращает идентификатор контрола и номер ячейки в этом контроле,
// соответствующей номеру index.
// При ошибке возвращается значение -1
int GetMultiHeaderItemWidth2(TVEWHeader &arr, int index, int *ctrlID, int *cellID);

// -----------------------------------------------------------------------------
// Найти поле с максимальной шириной из данных заголовка
// [out] pos   - Позиция поля по последней строке заголовка (совпадает с номерацией
//               полей в скроллинге.
// [out] index - Индекс найденной ячейки в контроле.
// [out] ctrl  - Индекс контрола, которому принадлежит найденная ячейка.
// [ret]       - Возвращает максимальную ширину (если > 0). Если вернула < 0, ошибка.
int GetMultiHeaderItemWidthMax(TVEWHeader &arr, int *pos, int *index, int *ctrl);

// -----------------------------------------------------------------------------
// Найти поле с максимальной шириной из данных заголовка в заданном контроле
// [in]  ctrl  - Индекс контрола, в котором производится поиск
// [out] index - Индекс найденной ячейки в контроле.
// [ret]       - Возвращает максимальную ширину (если > 0). Если вернула < 0, ошибка.
int GetMultiHeaderItemWidthMax2(TVEWHeader &arr, int ctrl, int *index);

// -----------------------------------------------------------------------------
// Получить смещение (левую или правую границу) колонки из данных заголовка
// [in]  right - false - смещение до левой границы ячейки,
//               true  - до правой
int GetMultiHeaderItemOffset(TVEWHeader &arr, int index, bool right = false);

// -----------------------------------------------------------------------------
// Получить высоту заголовка
int GetMultiHeaderHeight(TVEWHeader &arr);

// -----------------------------------------------------------------------------
// Обновить текущие ширины последних ячеек контрола
// [in]  hParentWnd - дескриптор родительского окна контролов заголовка
void UpdateMultiHeaderWidth(HWND hParentWnd, TVEWHeader &arr);

// -----------------------------------------------------------------------------
// Обновить текущие параметры ячеек контролов
// [in]  hParentWnd - дескриптор родительского окна контролов заголовка
void UpdateMultiHeader(HWND hParentWnd, TVEWHeader &arr);

// -----------------------------------------------------------------------------
// Обновить физические параметры ячеек и контролов по содержимому arr
// [in]  hParentWnd - дескриптор родительского окна контролов заголовка
void UpdateMultiHeader2(HWND hParentWnd, TVEWHeader &arr);

// -----------------------------------------------------------------------------
// Получить текст ячейки для заданного контрола и индекса ячейки
const TCHAR *GetMultiHeaderCellText(TVEWHeader &arr, HWND hWnd, int cellID);

#endif _MULTIHDR_H_

/* <-- EOF --> */